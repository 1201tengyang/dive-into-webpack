### 缩小文件搜索范围
Webpack 启动后会从配置的 Entry 出发，解析出文件中的导入语句，再递归的解析。
在遇到导入语句时 Webpack 会做两件事情：

1. 根据导入语句去寻找对应的要导入的文件。例如 `require('react')` 导入语句对应的文件是 `./node_modules/react/react.js`，`require('./util')` 对应的文件是 `./util.js`。
2. 根据找到的要导入文件的后缀，使用配置中的 Loader 去处理文件。例如使用 ES6 开发的 JavaScript 文件需要使用 babel-loader 去处理。

以上2件事情虽然对于处理一个文件非常快，但是当项目大了以后文件量会变的非常多，这时候构建速度慢的问题就会暴露出来。
虽然以上2件事情无法避免，但需要尽量减少以上2件事情的发生，以提高速度。
接下来一一介绍可以优化它们的途径。

#### 优化 resolve.modules 配置
在[2.4 Resolve](../2配置/2.4Resolve.md#modules)中介绍过 `resolve.modules` 用于配置 Webpack 去哪些目录下寻找第三方模块。

`resolve.modules` 的默认值是 `['node_modules']`，含义是先去当前目录下的 `./node_modules` 目录下去找想找的模块，如果没找到就去上一级目录 `../node_modules` 中找，再没有就去 `../../node_modules` 中找，以此类推。
当安装的第三方模块都放在项目目录下的 `./node_modules` 目录下时，没有必要按照默认的方式去一层层的寻找，可以指明存放第三方模块的绝对路径，以减少寻找，配置如下：
```js
module.exports = {
  // ...
  resolve: {
    // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤
    modules: [path.resolve(__dirname, 'node_modules')]
    // ...
  },
};
```

#### 优化 resolve.mainFields 配置
在[2.4 Resolve](../2配置/2.4Resolve.md#mainFields)中介绍过 `resolve.mainFields` 用于配置第三方模块的入口文件是哪个。

安装的第三方模块中都会有一个 `package.json` 文件用于描述这个模块的属性，其中有些字段用于描述入口文件在哪里，`resolve.mainFields` 用于配置采用哪个字段作为入口文件的描述。

可以存在多个字段描述入口文件的原因是因为有些模块可以同时用在多个环境中，准对不同的运行环境需要使用不同的代码。
以 [isomorphic-fetch](https://github.com/matthew-andrews/isomorphic-fetch) 为例，它是 [fetch API](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API) 的一个实现，但可同时用于浏览器和 Node.js 环境。
它的 `package.json` 中就有2个入口文件描述字段：
```json
{
  "browser": "fetch-npm-browserify.js",
  "main": "fetch-npm-node.js"
}
```

`resolve.mainFields` 的默认值和当前的 `target` 配置有关系：

- 当 `target` 为 `web` 或者 `webworker` 时，值是 `["browser", "module", "main"]`
- 当 `target` 为其它情况时，值是 `["module", "main"]`

以 `target` 等于 `web` 为例，Webpack 会先采用第三方模块中的 `browser` 字段去寻找模块的入口文件，如果不存在就采用 `module` 字段，以此类推。

为了减少搜索步骤，在你明确第三方模块的入口文件描述字段时，你可以把它设置的尽量少。因为大多数第三方模块都采用 `main` 字段去入口文件的位置，可以这样配置 Webpack：
```js
module.exports = {
  // ...
  resolve: {
    // 只采用 main 字段作为入口文件描述字段，以减少搜索步骤
    mainFields: ['main'],
    // ...
  },
};
```
> 使用本方法优化时你需要考虑到所有运行时依赖的第三方模块的入口文件描述字段，就算有一个模块搞错了都可能会找出构建出的代码无法正常运行。

#### 优化 resolve.alias 配置

#### 优化 resolve.extensions 配置

#### 优化 module.noParse 配置

#### 优化 loader 配置
