## 常见的构建工具及对比
在阅读完上一节[前端的发展](./前端的发展)后你一定会感叹前端技术发展之快，各种可以提高开发效率的新思想和框架被发明。但是这些东西都有一个共同点，源代码无法直接运行必须要通过转换后才可以正常运行。
构建就是做这个事情，把源代码转换成发布到线上的可执行的 JavaScrip、CSS、HTML 代码。
构建可以做很多事情，一般包括：
- 代码转换：TypeScript 编译成 JavaScript、SASS 编译成 CSS 等
- 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等
- 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载
- 模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件
- 自动刷新：监听本地源代码变化，自动编译刷新浏览器
- 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单页测试是否通过
- 自动发布：更新完代码后，自动构建出线上发布代码传输给发布系统

构建其实是工程化自动化思想在前端开发里的体现，把一系列流程用代码去实现，让代码自动化的去执行这一系列复杂的流程。
构建给前端开发注入了更大的活力，解放了我们的生产力。
历史上先后出现一系列构建工具，它们各有其优缺点，由于前端工程师很熟悉 JavaScript ，Nodejs又可以胜任所有构建需求这些构建构建都是用 Nodejs 开发的，下面来介绍下它们。

### Grunt
[Grunt](https://gruntjs.com) 是一个任务执行者，提供大量插件封装了常见的任务。Grunt 会管理任务之间的依赖关系自动化执行依赖的任务，每个任务的具体执行代码和依赖关系写在配置文件 `Gruntfile.js` 里，比如：
```js
module.exports = function(grunt) {
  // 所有插件的配置信息
  grunt.initConfig({
    // uglify 插件的配置信息
    uglify: {
        app_task: {
          files: {
            'build/app.min.js': ['lib/index.js', 'lib/test.js']
          }
        }
    },
    // watch 插件的配置信息
    watch: {
        another: {
            files: ['lib/*.js'],
        }
    }
  });

  // 告诉 grunt 我们将使用这些插件
  grunt.loadNpmTasks('grunt-contrib-uglify');
  grunt.loadNpmTasks('grunt-contrib-watch');

  // 告诉grunt当我们在终端中启动 grunt 时需要执行哪些任务
  grunt.registerTask('dev', ['uglify','watch']);
};
```
在项目根目录下执行命令 `grunt dev` 就会启动文件优化和自动刷新。

Grunt优点是：
- 灵活，它只负责执行你定义的任务
- 大量可复用插件封装好了常见的构建任务，无需自己实现构建代码

缺点是：
- 要写很多配置后才可以用，无法做到开箱即用

### Npm Script
[Npm Script](https://docs.npmjs.com/misc/scripts) 也是一个任务执行者，和 Grunt 类似。

- [Gulp]
- [Webpack]
- [Rollup]
- [Fis]
- [为什么选择Webpack]