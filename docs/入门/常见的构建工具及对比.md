## 常见的构建工具及对比
在阅读完上一节[前端的发展](./前端的发展.md)后你一定会感叹前端技术发展之快，各种可以提高开发效率的新思想和框架被发明。但是这些东西都有一个共同点，源代码无法直接运行必须要通过转换后才可以正常运行。
构建就是做这个事情，把源代码转换成发布到线上的可执行 JavaScrip、CSS、HTML 代码。
构建可以做很多事情，一般包括：
- 代码转换：TypeScript 编译成 JavaScript、SASS 编译成 CSS 等。
- 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。
- 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。
- 模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。
- 自动刷新：监听本地源代码变化，自动编译刷新浏览器。
- 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。
- 自动发布：更新完代码后，自动构建出线上发布代码传输给发布系统。

构建其实是工程化自动化思想在前端开发里的体现，把一系列流程用代码去实现，让代码自动化的去执行这一系列复杂的流程。
构建给前端开发注入了更大的活力，解放了我们的生产力。
历史上先后出现一系列构建工具，它们各有其优缺点，由于前端工程师很熟悉 JavaScript ，Nodejs 又可以胜任所有构建需求大多数构建构建都是用 Nodejs 开发的，下面来介绍下它们。

### Npm Script
[Npm Script](https://docs.npmjs.com/misc/scripts) 是一个任务执行者。Npm 是在安装 Nodejs 时附带的包管理器，Npm Script 则是 Npm 内置的一个功能，允许在 `package.json` 文件里面使用 `scripts` 字段定义任务：
```json
{
  "scripts": {
    "dev": "node dev.js",
    "pub": "node build.js"
  }
}
```
里面的 `scripts` 字段是一个对象，每一个属性对应一段脚本，以上定义了两个任务 `dev` 和 `pub`。底层实现原理是通过调用 Shell 去运行脚本命令，比如执行 `npm run pub` 命令等同于执行命令 `node build.js`。

**优点是：**
- Npm 是内置的，无需安装其它的模块。

**缺点是：**
- 功能太简单，虽然提供了 `pre` 和 `post` 两个钩子，但不能方便地管理多个任务之间的依赖。




### Grunt
[Grunt](https://gruntjs.com) 和 Npm Script 类似，也是一个任务执行者。Grunt 提供大量插件封装了常见的任务，也能管理任务之间的依赖关系自动化执行依赖的任务，每个任务的具体执行代码和依赖关系写在配置文件 `Gruntfile.js` 里，比如：
```js
module.exports = function(grunt) {
  // 所有插件的配置信息
  grunt.initConfig({
    // uglify 插件的配置信息
    uglify: {
      app_task: {
        files: {
          'build/app.min.js': ['lib/index.js', 'lib/test.js']
        }
      }
    },
    // watch 插件的配置信息
    watch: {
      another: {
          files: ['lib/*.js'],
      }
    }
  });

  // 告诉 grunt 我们将使用这些插件
  grunt.loadNpmTasks('grunt-contrib-uglify');
  grunt.loadNpmTasks('grunt-contrib-watch');

  // 告诉grunt当我们在终端中启动 grunt 时需要执行哪些任务
  grunt.registerTask('dev', ['uglify','watch']);
};
```
在项目根目录下执行命令 `grunt dev` 就会启动 JS 文件压缩和自动刷新。

**优点是：**
- 灵活，它只负责执行你定义的任务。
- 大量可复用插件封装好了常见的构建任务，无需自己实现构建代码。

**缺点是：**
- 集成度不高，要写很多配置后才可以用，无法做到开箱即用。

Grunt 可以看作是进化版的 Npm Script，它的诞生其实是为了弥补 Npm Script 的不足之处。



### Gulp
[Gulp](http://gulpjs.com) 是一个基于流的自动化构建工具。除了可以管理和执行任务外还支持监听文件、读写文件。Gulp 设计的非常简单只通过下面5个方法就可以胜任几乎所有构建场景：
- 通过 `gulp.task` 去注册一个任务
- 通过 `gulp.run` 去执行任务
- 通过 `gulp.watch` 去监听文件变化
- 通过 `gulp.src` 去读取文件
- 通过 `gulp.dest` 去写文件

Gulp 最大的特点是引入了**流**的概念，同时提供一系列常用的插件去处理流，流可以在插件之间传递，大致使用如下：
```js
// 引入 gulp
var gulp = require('gulp'); 
// 引入插件
var jshint = require('gulp-jshint');
var sass = require('gulp-sass');
var concat = require('gulp-concat');
var uglify = require('gulp-uglify');

// 编译 Sass 任务
gulp.task('sass', function() {
  // 读取文件通过管道喂给插件
  gulp.src('./scss/*.scss')
    // sass 插件把 scss 文件编译成 css 文件
    .pipe(sass())
    // 输出文件
    .pipe(gulp.dest('./css'));
});

// 合并压缩 JS
gulp.task('scripts', function() {
  gulp.src('./js/*.js')
    .pipe(concat('all.js'))
    .pipe(uglify())
    .pipe(gulp.dest('./dist'));
});

// 监听文件变化
gulp.task('watch', function(){
  // 当 scss 文件被编辑时执行 sass 任务
  gulp.watch('./scss/*.scss', ['sass']);
  gulp.watch('./js/*.js', ['scripts']);    
});
```

**优点是：**
- 好用又不失灵活，既可以单独完成构建也可以和其它工具搭配使用。

**缺点是：**
- 和 Grunt 类似，集成度不高，要写很多配置后才可以用，无法做到开箱即用。

Gulp 可以看作是 Grunt 的加强版，相比于 Grunt 它增加了监听文件、读写文件、流式处理的功能。



### Fis3
[Fis3](https://fex.baidu.com/fis3/) 是一个来自百度的优秀国产构建工具。相比于 Grunt、Gulp 这些只提供基本功能的工具来说，Fis3 集成了 Web 开发中常用的构建功能，包括：
- 读写文件：通过 `fis.match` 读文件，`release` 配置文件输出路径
- 资源定位：解析文件之间的依赖关系和文件位置
- 文件指纹：通过 `useHash` 配置输出文件时给文件 URL 加上 md5 戳来优化浏览器缓存
- 文件编译：通过 `parser` 配置文件解析器来做文件转换，比如把 ES6 编译成 ES5
- 压缩资源：通过 `optimizer` 配置文件优化方法做代码压缩
- 图片合并：通过 `spriter` 配置合并 CSS 里导入的图片到一个文件减少 HTTP 请求数

大致使用如下：
```js
// 加 md5
fis.match('*.{js,css,png}', {
  useHash: true
});

fis.match('*.ts', {
  // fis3-parser-typescript 插件把 ts 转换成 js
  parser: fis.plugin('typescript')
});

// 对 CSS 进行图片合并
fis.match('*.css', {
  // 给匹配到的文件分配属性 `useSprite`
  useSprite: true
});

fis.match('*.js', {
  // fis-optimizer-uglify-js 插件进行压缩，已内置
  optimizer: fis.plugin('uglify-js')
});

fis.match('*.css', {
  // fis-optimizer-clean-css 插件进行压缩，已内置
  optimizer: fis.plugin('clean-css')
});

fis.match('*.png', {
  // fis-optimizer-png-compressor 插件进行压缩，已内置
  optimizer: fis.plugin('png-compressor')
});
```

可以看出 Fis3 很强大，内置了许多功能无需做太多配置就能完成大量工作。

**优点是：**
- 集成各种 Web 开发所需的构建功能，配置简单开箱即用。

**缺点是：**
- 目前官方已经不再更新和维护，不支持最新版本的 Nodejs。

Fis3 是一个专注于 Web 开发的完整解决方案，如果把 Grunt、Gulp 比喻成汽车的发动机，Fis3 可比喻成一辆完成的汽车。



### Webpack
[Webpack](https://webpack.js.org) 是一个打包模块化 JavaScript 的工具，在 Webpack 里一切文件皆模块，通过 Loader 转换文件，通过 Plugin 注入钩子，最后输出由多个模块组合成的文件。
大致使用如下：
```js
module.exports = {
  // 所有模块的入口，Webpack 从入口开始递归解析出所有依赖的模块
  entry: './app.js',
  output: {
    // 把入口所依赖的所有模块打包成一个文件 bundle.js 输出 
    filename: 'bundle.js'
  }
}
```

**优点是：**
- 专注于处理模块化的项目，能做到开箱即用一步到位。
- 通过 Plugin 扩展，完整好用又不失灵活。
- 使用场景不仅限于 Web 开发。
- 社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展。
- 良好的开发体验。

**缺点是：**
- 只能用于采用模块化开发的项目。

Webpack 专注于构建模块化项目，由于它是本书的主角后面再详细介绍。



### Rollup
[Rollup](https://rollupjs.org) 是一个和 Webpack 很类似但专注于 ES6 的模块打包工具。
Rollup 的亮点在于能针对 ES6 源码进行 *tree-shaking* 去除那些定义了但是没有使用的代码。
然而 Rollup 唯一的亮点 *tree-shaking* 随后就被 Webpack 模仿和实现。
由于 Rollup 的使用和 Webpack 差不多这里就不详细介绍如何使用，而是来详细说说它和 Webpack 的不同：
- Rollup 是在 Webpack 流行后出现的替代品。
- 目前没有 Rollup 做得到 Webpack 做不到的事情。
- 目前没有 Rollup 比 Webpack 做的好的事情。
- Rollup 生态链还不完善，开发体验不如 Webpack。

似乎找不到理由去使用 Rollup 替代 Webpack。



### 为什么选择 Webpack
上面介绍的构建工具是按照它们诞生的时间排序的，它们是时代的产物侧面反映出 Web 开发的发展趋势如下：
1. Npm Script 和 Grunt 时代，Web 开发要做的事情变多，流程复杂，自动化思想被引入去简化流程。
2. Gulp 时代开始出现一些新语言用于提高开发效率，流式处理思想是为了方便文件转换流程，例如把 ES6 转换成 ES6。
3. Webpack 时代由于单页应用的流行，Web 开发向模块化改进。

这些构建工具都有各自的定位和专注点，它们之间既可以单独地完成任务也可以相互搭配起来弥补各自的不足。
在你了解这些常见的构建工具后，你需要根据自己的需求去判断你应该如何选择和搭配它们才能更好地完成你的需求。

经过多年地发展 Webpack 已经成为构建工具里的第一，这是有原因的：
- 大多数团队在开发新项目是会采用紧跟时代的技术，这些技术几乎都会采用 模块化+新语言+新框架，Webpack 可以为这些新项目提供一站式的解决方案。
- Webpack 有良好的生态链和维护团队，能提供良好的开发体验和保证质量。
- Webpack 被全世界的大量 Web 开发者使用和验证，能找到各个层面所需的教程和经验分享。

下面开始跨入 Webpack 的大门吧！
